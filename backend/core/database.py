import logging
import os
import psycopg2
from psycopg2.extras import execute_values

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

DATABASE_URL = os.environ.get('DATABASE_URL', 'postgresql://user:password@localhost:5432/vector_db')
# The dimension of the embeddings generated by mxbai-embed-large
EMBEDDING_DIMENSION = 1024

def get_db_connection():
    """
    Establishes a connection to the PostgreSQL database.

    Returns:
        psycopg2.connection: A connection object or None if connection fails.
    """
    try:
        conn = psycopg2.connect(DATABASE_URL)
        return conn
    except psycopg2.OperationalError as e:
        logger.error(f"Could not connect to the database: {e}", exc_info=True)
        return None

def setup_database(conn):
    """
    Creates the 'documents' table with a vector column if it does not already exist.
    Also enables the pgvector extension.
    """
    # Enable the vector extension
    enable_extension_query = "CREATE EXTENSION IF NOT EXISTS vector;"

    # Add the 'embedding' column with the correct dimension
    create_table_query = f"""
    CREATE TABLE IF NOT EXISTS documents (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        publication_date DATE,
        source VARCHAR(255),
        content TEXT, -- Placeholder for full document content
        embedding VECTOR({EMBEDDING_DIMENSION}), -- Column for storing text embeddings
        ingested_at TIMESTAMP WITH TIME ZONE DEFAULT CURRENT_TIMESTAMP
    );
    """
    try:
        with conn.cursor() as cur:
            cur.execute(enable_extension_query)
            logger.info("'vector' extension enabled or already exists.")
            cur.execute(create_table_query)
            logger.info("'documents' table with vector column created or already exists.")
        conn.commit()
    except psycopg2.Error as e:
        logger.error(f"Error during table setup: {e}", exc_info=True)
        conn.rollback()

def insert_documents(conn, documents: list[dict]):
    """
    Inserts a list of processed documents into the 'documents' table.
    It ignores documents with IDs that already exist in the table.

    Args:
        conn (psycopg2.connection): The database connection object.
        documents (list[dict]): A list of document dictionaries to insert.
    """
    if not documents:
        logger.info("No documents to insert.")
        return

    insert_query = """
    INSERT INTO documents (id, title, publication_date, source)
    VALUES %s
    ON CONFLICT (id) DO NOTHING;
    """

    data_to_insert = [(doc.get('id'), doc.get('title'), doc.get('publication_date'), doc.get('source')) for doc in documents]

    try:
        with conn.cursor() as cur:
            execute_values(cur, insert_query, data_to_insert)
        conn.commit()
        logger.info(f"Successfully processed {len(data_to_insert)} documents for insertion/update.")
    except psycopg2.Error as e:
        logger.error(f"Error inserting documents: {e}", exc_info=True)
        conn.rollback()

def get_documents_without_embedding(conn, limit: int = 10) -> list[tuple[str, str]]:
    """
    Retrieves documents that have not yet been vectorized.

    Args:
        conn (psycopg2.connection): The database connection object.
        limit (int): The maximum number of documents to retrieve.

    Returns:
        list[tuple[str, str]]: A list of tuples, each containing the document ID and title.
    """
    select_query = "SELECT id, title FROM documents WHERE embedding IS NULL LIMIT %s;"
    try:
        with conn.cursor() as cur:
            cur.execute(select_query, (limit,))
            docs = cur.fetchall()
            logger.info(f"Found {len(docs)} documents without embeddings.")
            return docs
    except psycopg2.Error as e:
        logger.error(f"Error fetching documents without embeddings: {e}", exc_info=True)
        return []

def update_document_embedding(conn, doc_id: str, embedding: list[float]):
    """
    Updates a document in the database with its generated embedding.

    Args:
        conn (psycopg2.connection): The database connection object.
        doc_id (str): The ID of the document to update.
        embedding (list[float]): The embedding vector to store.
    """
    if not embedding:
        logger.warning(f"Skipping embedding update for document {doc_id} due to empty embedding.")
        return

    update_query = "UPDATE documents SET embedding = %s WHERE id = %s;"

    try:
        with conn.cursor() as cur:
            cur.execute(update_query, (embedding, doc_id))
        conn.commit()
        logger.info(f"Successfully updated embedding for document {doc_id}.")
    except psycopg2.Error as e:
        logger.error(f"Error updating embedding for document {doc_id}: {e}", exc_info=True)
        conn.rollback()

if __name__ == '__main__':
    # This block is for demonstration and requires a running database.
    print("--- Testing Database Module with Vector Support ---")

    connection = get_db_connection()
    if connection:
        print("Successfully connected to the database.")

        # 1. Setup database (create extension and table)
        setup_database(connection)

        # 2. Insert sample data
        sample_docs = [
            {'id': 'VEC-TEST-1', 'title': 'Test document for vectorization', 'publication_date': '2023-01-01', 'source': 'VEC_TEST'},
            {'id': 'VEC-TEST-2', 'title': 'Another test document', 'publication_date': '2023-01-02', 'source': 'VEC_TEST'},
        ]
        print(f"\nAttempting to insert {len(sample_docs)} documents...")
        insert_documents(connection, sample_docs)

        # 3. Retrieve documents needing embedding
        docs_to_vectorize = get_documents_without_embedding(connection, limit=5)
        assert len(docs_to_vectorize) == 2
        print(f"\nFound {len(docs_to_vectorize)} documents to vectorize.")

        # 4. Update one document with a dummy embedding
        doc_id_to_update = docs_to_vectorize[0][0]
        dummy_embedding = [0.1] * EMBEDDING_DIMENSION
        print(f"Updating document {doc_id_to_update} with a dummy embedding...")
        update_document_embedding(connection, doc_id_to_update, dummy_embedding)

        # 5. Verify that one document is left to vectorize
        docs_to_vectorize_after = get_documents_without_embedding(connection, limit=5)
        assert len(docs_to_vectorize_after) == 1
        print(f"After update, found {len(docs_to_vectorize_after)} documents to vectorize.")

        # 6. Verify the embedding was stored
        with connection.cursor() as cur:
            cur.execute("SELECT embedding FROM documents WHERE id = %s;", (doc_id_to_update,))
            stored_embedding = cur.fetchone()[0]
            # psycopg2 returns numpy arrays for vectors
            assert len(stored_embedding) == EMBEDDING_DIMENSION
            assert stored_embedding[0] == 0.1
            print(f"Successfully verified stored embedding for {doc_id_to_update}.")

            # Clean up test data
            cur.execute("DELETE FROM documents WHERE source = 'VEC_TEST';")
        connection.commit()
        print("\nCleaned up test data.")

        connection.close()
        print("Database connection closed.")
    else:
        print("Failed to connect to the database. Skipping tests.")

    print("\n--- Database Module testing complete ---")